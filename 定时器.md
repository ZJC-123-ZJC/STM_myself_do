# 定时器

创作者：张锦程

时间：2021.8.1

以下笔记大部分摘自b站up主：小蜜蜂老师

实战使用开发板：正点原子stm32f103mini（芯片为stm32f103rct6）

本节笔记详细介绍了**定时器中断**与**定时器PWM输出**的功能及应用

定时器输入捕获请参考下节CSDN博主Z小璇

## 1. 基本概念

更详细的概念讲解可查看CSDN的**Z小璇**博主https://blog.csdn.net/as480133937/article/details/99201209

以及b站up主：**成电应电科协**的**《STM32入门教程(基于HAL库+CubeMX+MDK-ARM)》-定时器篇**

------

以下*基本概念*均摘自b站up主**小蜜蜂老师**

**定时器的基本概述**

可通过**滴漏**和**漏沙瓶**这两个例子简单讲述定时器的基本工作原理。
STM32的常见的定时器资源： **系统嘀嗒定时器SysTick**、**看门狗定时器WatchDog**、**实时时钟RTC**、**基本定时器**、**通用定时器**、**高级定时器**。

系统嘀嗒定时器SysTick ：这是一个集成在Cortex M3内核当中的定时器，它并不属于芯片厂商的外设，也就是说使用ARM内核的不同厂商，都拥有基本结构相同的系统定时器。主要目的是**给RTOS提供时钟节拍**做时间基准。
基本定时器：TIM6、TIM7。
**通用定时器：TIM2、TIM3、TIM4、TIM5**。在基本定时器的基础上，实现**输出比较、输入捕获、PWM生成、单脉冲模式输出**等功能。这类定时器最具代表性，使用也最广泛
高级定时器：TIM1、TIM8。

**STM32的每个通用定时器都有独立的4个通道可以用来作为：输入捕获、输出比较、PWM输出、单脉冲模式输出等。**



### **STM32通用定时器的重要知识点**

通用定时器的**基本结构组成**：
STM32的通用定时器,是一个通过可编程预分频器（**Prescaler**）驱动的16位自动重装主计数器（**Counter Period or ARR**）构成。可以对内部时钟或触发源以及外部时钟或触发源进行计数。

通用定时器的**基本工作原理**：
首先，定时器时钟信号送入16位可编程预分配器（Prescaler），该预分配器系数为0～65535之间的任意数值。预分配器溢出后，会向16位的主计数器（Counter Period）发出一个脉冲信号。
**预分频器**，*本质上是一个加法计数器，预分频系数实际上就是加计数的溢出值。*



#### 定时器发生中断**时间的计算方法**：

定时时间 = **(Prescaler+1 ) * (Counter Period+1) * 1/ 定时器时钟频率**
时钟信号1KHz，Prescaler为9，Counter Period（ARR）为999，定时时间？

![img](https://www.xmf393.com/wp-content/uploads/2020/02/STM32%E5%AE%9A%E6%97%B6%E5%99%A8%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97.png)

**定时器计数模式**：
通用定时器可以向上计数、向下计数、向上向下双向计数模式。

向上计数模式：计数器从0计数到自动加载值（TIMx_ARR），然后重新从0开始计数并且产生一个计数器溢出事件。
向下计数模式：计数器从自动装入的值（TIMx_ARR）开始向下计数到0，然后从自动装入的值重新开始，并产生一个计数器向下溢出事件。
中央对齐模式（向上/向下计数）：计数器从0开始计数到自动装入的值-1，产生一个计数器溢出事件，然后向下计数到1并且产生一个计数器溢出事件；然后再从0开始重新计数。
简单地理解三种计数模式，可以通过下面的图形：


![img](20180417164424341)





------

### **PWM输出知识点**

此处笔记参考的是**成电应电科协**

**什么是PWM：**

 脉冲宽度调制(PWM)，是英文“Pulse Width Modulation”的缩写，简称**脉宽调制**，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，广泛应用在从测量、通信到功率控制与变换的许多领域中。 

补充：

#### 定时器通道结构

![image-20210801214908689](image-20210801214908689.png)

定时器功能单元作用

![image-20210801214943633](image-20210801214943633.png)

#### PWM输出原理：

**PWM频率：**

**Fpwm =Tclk / ((arr+1)\*(psc+1))(单位：Hz)**

- arr 是计数器值
- psc 是预分频值

or 计算周期

**PWM周期：**

**Period =((arr+1)*(psc+1))/Tclk  (单位：s)**

- arr 是计数器值
- psc 是预分频值

**占空比：**

- **duty circle = TIM3->CCR1 / arr+1(单位：%)**
- TIM3->CCR1 用户设定值

![image-20210801215125192](image-20210801215125192.png)

应用实例：

![image-20210801215227790](image-20210801215227790.png)

多通道输出概念：

![image-20210801215242063](image-20210801215242063.png)

#### PWM输出的两种模式：

**PWM的工作模式：**
PWM模式1(向上计数)  :计数器从0计数加到自动重装载值(TIMx_ARR)，然后重新从0开始计数，并且产生一个计数器溢出事件   
PWM模式2(向下计数)  :计数器从自动重装载值(TIMx_ARR)减到0，然后重新从重装载值(TIMx_ARR)开始递减，并且产生一个计数器溢出事件 

![image-20210801215303644](image-20210801215303644.png)

#### **总结：**

**每个定时器有四个通道,每一个通道都有一个捕获比较寄存器,** 

**将寄存器值和计数器值比较,通过比较结果输出高低电平,便可以实现脉冲宽度调制模式（PWM信号）**

**TIMx_ARR寄存器确定PWM频率，**

**TIMx_CCRx寄存器确定占空比**



------



## 2. 定时器中断

### 相关接口函数：

#### （1）时基单元初始化函数

![image-20210801215705222](image-20210801215705222.png)

#### （2）轮询模式启动函数

![image-20210801215715689](image-20210801215715689.png)

轮询与中断的方式比较请参考https://www.cnblogs.com/jacklong-yin/p/11263052.html#

or https://zhuanlan.zhihu.com/p/163195429

#### （3）中断模式启动函数（常用）

![image-20210801215723170](image-20210801215723170.png)

#### （4）中断通用处理函数

![image-20210801215912263](image-20210801215912263.png)

#### （5）定时器更新中断回调函数（常用）

![image-20210801220204822](image-20210801220204822.png)

#### （6）计时器读取函数

![image-20210801220227792](image-20210801220227792.png)

#### （7）定时器中断标志清楚函数（常用）

![image-20210801220310559](image-20210801220310559.png)

### 程序编写基本步骤：

#### 1.在CubeMX中配置TIM

![image-20210801131140782](C:\Users\张aa\AppData\Roaming\Typora\typora-user-images\image-20210801131140782.png)

#### 2.编写中断服务函数

![image-20210801131149824](C:\Users\张aa\AppData\Roaming\Typora\typora-user-images\image-20210801131149824.png)

### 实战：

(1)使用TIM2实现间隔定时，每隔0.2秒将LED0的开关状态翻转

(2)使用TIM3实现间隔定时，每隔1秒将LED1的开关状态翻转

(3)修改TIM2的初始化代码，改为每隔0.5秒将LED0的开关状态翻转（略）

#### 1.时钟配置

设置外部时钟

![image-20210801133048844](C:\Users\张aa\AppData\Roaming\Typora\typora-user-images\image-20210801133048844.png)

将外设输出设为**32MHz**（32*10^6即32000000Hz)，可见APB1 Timer clocks的频率也为**32MHz**

![image-20210801132940173](C:\Users\张aa\AppData\Roaming\Typora\typora-user-images\image-20210801132940173.png)

#### 2.引脚、定时器配置：

LED0 -> DS0 -> PA8

LED1 -> DS1 -> PD2

3.配置定时器

TIM2

![](../../../../../../../Typora/document/TIM.png)

预分频器（**Prescaler**）设置为31999，即32000-1

320000/32MHz = 1 ms

主计数器（**Counter Period**）设置为199，即200-1

即200ms

![](../../../../../../../Typora/document/TIM2.png)



TIM3

![](TIM3.png)

#### 3.打开工程

可看见定时器中断服务函数所在位置（详见中断那节）

![image-20210801140329621](image-20210801140329621.png)

转到定时器中断处理函数的定义，可找到我们的回调函数

![](TIM5.png)

再跳转，可看见原型，类似外部中断，同样是个“虚函数”，有weak定义

![img](`YXFQHKW3L]9TYVBNO`K[G2.png)

#### 4.在main.c中重写回调函数

![](TIM6.png)

#### 5.**在main函数中启动相应定时器**

先找到启动函数，由于我们使用的是定时器中断，所以要 **HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)**函数，即定时器中断模式启动函数。

![](TIM7.png)

启动函数传入的参数是定时器实例

在tim.c中可以找到

![](TIM8.png)

最终在main函数中写入启动函数即可

![img](5]$E4NU8K0I9A`1PP1O`Y43.png)



定时器3的函数编写与2相同，只需在回调函数中写入功能即可。

![image-20210801143019626](image-20210801143019626.png)

main函数中

![image-20210801142543498](image-20210801142543498.png)



**细节！**

不要直接启动定时器，最好先清除定时器初始化过程中的更新中断标值，避免定时器一启动就进入中断。

采用**_HAL_TIM_CLEAR_IT(TIM_HandleTypeDef *htim，TIM_IT_UPDATE)**函数

![image-20210801164713826](image-20210801164713826.png)

修改定时时间可在此处修改，改预分频器及主计时器数值即可。

![image-20210801142725061](image-20210801142725061.png)

## 3. PWM输出

### 相关接口函数：

#### （1）定时器PWM输出启动函数

![image-20210801215402238](image-20210801215402238.png)

#### （2）定时器比较/捕获寄存器设置函数

![image-20210801215420438](image-20210801215420438.png)

### 程序编写基本步骤：

与定时器中断写法大致相同，不同的在于定时器配置

### 实战：呼吸灯

更高阶的呼吸灯做法请参考CSDN博主Bruceoxl的文章https://bruceou.blog.csdn.net/article/details/109149203?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-16.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-16.control

##### 内容：

利用PWM信号控制LED0，设置PWM周期为20ms，占空比从0%开始，步进为20%。递增到100%后，又从0%开始，并重复这过程。占空比修改的时间间隔为100ms。

##### 设计思路：

1.定义2个变量:占空比Duty和步进值Step

占空比从0%逐次步进到100%,步进比例为20%，步进时间间隔为100ms

由PWM信号的周期为20ms,定时器2的定时器时钟TIM1_ CLK为72MHz

根据公式

**PWM周期：** **Period =((arr+1)*(psc+1))/Tclk  (单位：s)**

可以设置预分频系数PSC为 9999，自动重载值ARR为143;

2.占空比从0%开始

因此写入捕获/比较寄存器CCR的初值为0,然后在while循环中调用宏函数_ HAL TIM_ SET_ COMPARE修改CCR的内容，

从0开始,逐渐增加到200，步进值为40。并重复该过程。

#### 1.时钟配置

![image-20210801225828368](image-20210801225828368.png)

- 1选择外部时钟HSE 8MHz  
- 2PLL锁相环倍频72倍
- 3系统时钟来源选择为PLL
- 4设置APB1分频器为 /2

![image-20210801225635919](image-20210801225635919.png)

#### 2.引脚、定时器配置

##### 引脚配置：

LED0 -> DS0 -> PA8

![image-20210801225933634](image-20210801225933634.png)

##### 定时器配置：

- **1.选择TIM1** 
- **2.设置定时器时钟源为内部时钟源**
- **设置定时器CH1为PWM模式**
- **3.对应管脚自动设置为复用模式**
- **4.可自行选择是否开启定时器中断**

- **5.Mode**  选择PWM模式1
- **6.Pulse(占空比值)** 先给0  此处值为捕获/比较值CRR（占空比计算公式为**duty circle = Pulse/（arr+1）(单位：%)**）
- **7.Fast Mode**  PWM脉冲快速模式  ： 和我们配置无关，不使能
- **8.PWM 极性：**  设置为低电平    PS: **由于LED是低电平点亮，所以我们把极性设置为low**

![image-20210801231334521](image-20210801231334521.png)

由设计思路，可知配置psc=9999，arr=143

![image-20210801234209707](image-20210801234209707.png)

#### 3.打开工程

#### 4.编写程序功能

由设计思路：

1.定义2个变量:占空比Duty和步进值Step（main.c）

![image-20210801235207076](image-20210801235207076.png)

2.占空比从0%开始

因此写入捕获/比较寄存器CCR的初值为0,然后在while循环中调用宏函数_ HAL TIM_ SET_ COMPARE修改CCR的内容，

从0开始,逐渐增加到200，步进值为40。并重复该过程。



找到定时器比较/捕获寄存器设置函数__HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__)的定义

![](PWM.png)

写出功能函数PWM_LED

![image-20210802000036940](image-20210802000036940.png)

最后在main函数中调用该函数。（图略）

#### 5.在main函数启动定时器

![img](A@TWZ8GX$7GX[}9M8T47OD.png)

实现双向呼吸灯只需

![](PWM2.png)

