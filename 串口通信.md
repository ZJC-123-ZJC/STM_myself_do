# 串口通信

创作者：张锦程

时间：2021.8.2

以下笔记大部分摘自b站up主：小蜜蜂老师，成电应电科协，及CSDN博主Z小璇

实战使用开发板：正点原子stm32f103mini（芯片为stm32f103rct6）

本节笔记将介绍串口通信的三种方式以及DMA的概念与用法

1. **轮询（阻塞式）**方式的串口通信（发完数据才能做其他事情）
2. **中断（非阻塞式）**方式的串口通信
3. **DMA**方式的串口通信

本文时钟均采用以下配置

外部晶振为8MHz

- 1选择外部时钟HSE 8MHz
- 2PLL锁相环倍频9倍
- 3系统时钟来源选择为PLL
- 4设置APB1分频器为 /2
- 5 使能CSS监视时钟

![image-20210803001103950](image-20210803001103950.png)

## 一、基本概念

### 计算机通信基本概念

#### 并行通信

![image-20210802140716036](image-20210802140716036.png)

#### 串行通信

![image-20210802140734880](image-20210802140734880.png)

##### 同步串行通信

![image-20210802140835887](image-20210802140835887.png)

##### 异步串行通信（重点）

###### 特点：

![image-20210802140901672](image-20210802140901672.png)

###### 字符格式：

![image-20210802140925483](image-20210802140925483.png)

###### 通信速率：

![image-20210802141002946](image-20210802141002946.png)

###### 通信准确性：

字符格式和波特率！

![image-20210802141027172](image-20210802141027172.png)

###### 数据接受过程：

![image-20210802141054216](image-20210802141054216.png)

#### 串口通信的数据传输方向：

![image-20210802141131418](image-20210802141131418.png)

#### 错误校验：

![image-20210802141147622](image-20210802141147622.png)



------



### STM32的串口通信

![image-20210802143117186](image-20210802143117186.png)

![image-20210802143127992](image-20210802143127992.png)

![image-20210802143132000](image-20210802143132000.png)

### 串口的数据类型定义

详情了解b站up主成电应电科协的课程 or 自己查看源码



------



## 二、串口通信实战

### 0.硬件条件

参考正点原子的《STM32不完全手册》可知，STM32f103mini的串口1

串口1：USART1_**TX**与**PA9复用，USART1_**RX**与**PA10**复用。

本实验用到的串口 1 与 USB 串口并没有在 PCB 上连接在一起， 需要通过跳线帽来连接一下。这里我们把 P4 的 RXD 和 TXD 用跳线帽与 PA9 和 PA10 连接起 来。

如图 8.2.1 所示：

![image-20210802145218804](image-20210802145218804.png)

------



### 1.轮询方式的串口通信

#### 接口函数

##### （1）初始化函数

![image-20210802144829267](image-20210802144829267.png)

##### （2）发送函数

![image-20210802144901816](image-20210802144901816.png)

##### （3）接收函数![image-20210802144935622](image-20210802144935622.png)

​	

------



#### 实战1.1：固定长度的数据收发

内容：

从PC上发送5各字符到开发板， 开发板收到后将字符原样发会到PC

##### 0.配置时钟 （略）

##### 1.串口外设配置

![image-20210802154339100](image-20210802154339100.png)

##### 2.程序编写

先定义接受缓冲区

![image-20210802155117642](image-20210802155117642.png)

可找到串口初始化函数

![image-20210802155210719](image-20210802155210719.png)

![](UART.png)

主程序编写：

![image-20210802155700491](image-20210802155700491.png)

##### 3.效果：

![image-20210802160047637](image-20210802160047637.png)



------

#### 实战1.2：实现串口重定向（重点）

任务目标：利用串口实现printf函数和scanf函数

任务内容：在PC上利用串口调试助手发送数据到MCU，MCU调用scanf函数读取数据，然后调用printf函数发送应答信息到PC

##### 设计思路

##### 程序编写

###### 1.添加头文件

![image-20210802161036952](image-20210802161036952.png)

###### 2.重定义fputc函数和fgetc函数

![image-20210802205936298](image-20210802205936298.png)

```c
/* USER CODE BEGIN 4 */
/*
 * @brief Retargets the C library printf function to the USART
 * @param None
 * @retval None
*/
int fputc(int ch,FILE *f)
{
	// 采用轮询方式发送1字节的数据，超时时间设置为无限等待HAL_MAX_DELAY
	HAL_UART_Transmit(&huart1,(uint8_t *)&ch,1,HAL_MAX_DELAY);
	return ch;
}
/*
 * @brief Retargets the C library scanf function to the USART
 * @param None
 * @retval None
*/
int fgetc(FILE *f)
{
	uint8_t ch;
	// 采用轮询方式接受1字节的数据，超时时间设置为无限等待HAL_MAX_DELAY
	HAL_UART_Receive(&huart1,(uint8_t *)&ch,1,HAL_MAX_DELAY);
	return ch;
}
```



###### 3.主程序编写

![image-20210802162146322](image-20210802162146322.png)

###### **注意！**

编译前必须勾选

![image-20210802180656274](image-20210802180656274.png)

##### 效果

![image-20210802162922958](image-20210802162922958.png)

更详细的重定向printf可以参考https://blog.csdn.net/BearPi/article/details/104310502



------



### 2.中断方式的串口通信

#### 中断方式的特点：

![image-20210802174020112](image-20210802174020112.png)

尤其注意第三点：
3.在传输数据量较大，且通信波特率较高(大于38400) 时,如果采用中断方式，每收发一个字节的数据，CPU都会被打断，造成CPU无法处理其他事务。因此在批量数据传输，通信波特率较高时，建议采用**DMA**方式。

####  接口函数

##### （1）串口中断发送函数（常用）

![image-20210802174518375](image-20210802174518375.png)

##### （2）串口中断接收函数（常用）

![image-20210802174526824](image-20210802174526824.png)

##### （3）串口中断通用处理函数

![image-20210802174531552](image-20210802174531552.png)

##### （4）串口发送中断回调函数（常用）

![image-20210802174537691](image-20210802174537691.png)

##### （5）串口接受中断回调函数（常用）

![image-20210802175000880](image-20210802175000880.png)

##### （6）串口中断使能函数

![image-20210802175006574](image-20210802175006574.png)

##### （7）串口中断标志查询函数

![image-20210802175012389](image-20210802175012389.png)

##### （8）空闲中断标志清除函数

![image-20210802175016924](image-20210802175016924.png)



------



#### 实战2.1：固定长度数据收发

##### 设计思路：

前后台编程模式

1.采用前后台编程模式;

2.前台程序为中断服务程序，一旦数据接收完成，则设置一个标志位为1;

3.后台程序为while(1)的死循环，在循环中不断检测标志位是否为1。如果为1, 表明数据接收完成，并存放在接收缓冲区中。

​	然后进行后续处理:先清除标志位，再把接收的数据原样发回。

##### 程序编写：

###### 0.配置时钟（略）

###### 1.串口外设配置

基本与上面的轮询一样，但需要注意使能串口中断

![image-20210802203125519](image-20210802203125519.png)

###### 2.程序编写

注意：使用printf记得先串口重定向（上小节），使用中断式

```c
/* USER CODE BEGIN 4 */

/*
 * @brief Retargets the C library printf function to the USART
 * @param None
 * @retval None
*/
int fputc(int ch,FILE *f)
{
	// 采用中断方式发送1字节的数据
	HAL_UART_Transmit_IT(&huart1,(uint8_t *)&ch,1);
	return ch;
}
/*
 * @brief Retargets the C library scanf function to the USART
 * @param None
 * @retval None
*/
int fgetc(FILE *f)
{
	uint8_t ch;
	// 采用中断方式接受1字节的数据
	HAL_UART_Receive_IT(&huart1,(uint8_t *)&ch,1);
	return ch;
}

```

先定义接受缓冲区变量和标志位

![image-20210802203747348](image-20210802203747348.png)

![](image-20210802203756684.png)

重写接受中断回调函数

功能：若接受到数据，则标志位改为1，并使能接收中断

![image-20210802203905772](image-20210802203905772.png)

##### 效果：

![image-20210802203925857](image-20210802203925857.png)

![image-20210802212702724](image-20210802212702724.png)

##### 注意！

设置的接收数据步长是10位，则一次发10位才能被完整接受到，且第一位置空

实际工程中注意每次收发要清空缓冲区，一般写在中断接收回调函数中。

##### 总结与梳理

梳理串口通信中断的流程：

![image-20210802214019539](image-20210802214019539.png)

------



#### 实战2.2：实现简单的帧格式通信

任务内容：PC按照自定义的帧格式发送指令开启或关闭开发板上的LED0

##### 补充概念：

###### 帧格式概念：

![image-20210802214054086](image-20210802214054086.png)

###### Modbus消息帧格式：

Modbus协议详情请看

https://blog.csdn.net/panda5_csdn/article/details/94332166

https://blog.csdn.net/qq_39400113?spm=1001.2014.3001.5509

![image-20210802214103989](image-20210802214103989.png)

###### 自定义帧：

![image-20210802214108787](image-20210802214108787.png)

##### 

##### 实现：

2~4步与实验2.1基本一致

###### 0.配置（略）

###### 1.定义各种变量

接收缓冲区RxBuffer，接收完成标志RxFlag，指令错误标志ErrFlag

###### 2.用户初始化代码

图中的huart2应为huart1（根据实际情况改）

![image-20210802215950026](image-20210802215950026.png)

###### 3.串口重定向（中断方式）

略，详见实验2.1

###### 4.重写中断接收回调函数

略，详见实验2.1

###### 5.主程序

思路：先判断数据是否接收完成，再进行帧格式的解析。

帧格式解析：（1）判断帧头帧尾（2）判断设备码（3）判断功能码

![image-20210802220132016](image-20210802220132016.png)

![image-20210802220137623](image-20210802220137623.png)

![image-20210802220142305](image-20210802220142305.png)

##### 效果：

![image-20210802220155068](image-20210802220155068.png)



------



### 3.DMA方式的串口通信（重要）

由中断方式的特点3可知

3.在传输数据量较大，且通信波特率较高(大于38400) 时,如果采用中断方式，每收发一个字节的数据，CPU都会被打断，造成CPU无法处理其他事务。因此在批量数据传输，通信波特率较高时，建议采用**DMA**方式。

------

更详细的可看CSDN博主Z小璇的文章《DMA原理，步骤超细详解，一文看懂DMA》

**https://blog.csdn.net/as480133937/article/details/104927922**

以及CSDN博主Bruceoxl的https://bruceou.blog.csdn.net/article/details/109267950

#### 基本概念：

##### 1.基本概念

DMA ：Direct Memory Access

![image-20210802234400359](image-20210802234400359.png)

##### 2.DMA控制器特点

1. STM32F103微控制器具备两个DMA控制器: DMA1和DMA2,每个控制器有8个数据流，每个数据流可以映射到8个通道(或请求) ;
2. 每一个DMA控制器用于管理一个或多个外设的存储器访问请求，并通过总线仲裁器来协调各个DMA请求的优先级;
3. 数据流(stream) 是用于连接传输源和传输目标的数据通路，每个数据流可以配置为不同的传输源和传输目标，这些传输源和传输目标称为通道(Channel) ;
4. 具备1 6字节的FIFO。使能FIFO功能后，源数据先送入FIFO,达到FIFO的触发闻值后，再传送到目标地址。

##### 3.DMA框图

![image-20210802234433385](image-20210802234433385.png)

##### 4.数据传输方式

![image-20210802234447956](image-20210802234447956.png)



------



#### 接口函数

##### (1)发送函数

![image-20210802234752882](image-20210802234752882.png)

##### (2)接收函数

![image-20210802234800997](image-20210802234800997.png)

##### (3)获取未传输数据个数函数

![image-20210802234804963](image-20210802234804963.png)



------

#### 实战3.1：不定长数据的收发

内容：利用串口调试助手，从PC上发送任意长度的字符到开发板上，然后开发板收到后原样发回到PC



原理：在 STM32 中。USART 发送接收有三种基本方式，轮询、中断和 DMA。轮询方式为堵塞模式，使用超时管理机制。它每次接收一个字节，在规定时间内接收固定长度的数据。在对于某些数据不固定长度接收的数据，轮询的方式有时候不够灵活。也可以使用中断的方式，如每一个字节都中断一次，当时比较消耗系统资源。特别是HAL库中，从中断到回调函数运行了不少的程序，频繁的中断很可能造成数据溢出。为了避免这个问题，我们使用指定接收一定长度的数据，再调用回调函数，这会让我们可以接收大数据，但是这种情况则造成了，要求每次的包是固定长度。为了解决以上一些问题，网上最常用的办法是使用空闲中断，即在串口空闲的时候，触发一次中断，通知内核，本次运输完成了。数据传输过程为了尽量不占用CPU的处理数据时间,所以就使用DMA接收串口的数据。


##### 补充概念：

###### 空闲中断的特点：

STM32的IDLE的中断产生条件：在串口无数据接收的情况下，不会产生，当清除IDLE标志位后，必须有接收到第一个数据后，才开始触发，一但接收的数据断流，没有接收到数据，即产生IDLE中断

![image-20210802235255276](image-20210802235255276.png)

###### 空闲中断的时序图：

![image-20210802235301868](image-20210802235301868.png)

##### 设计思路

0.**使能IDLE中断**，在串口1的**中断服务程序USART1_ IRQHandler中添加对IDLE中断的判断**，该函数位于stm32f1xx_ it.c文件; 

1.设置传输模式为**普通模式**，**启动DMA传输**。**串口一旦接收到数据,则触发DMA操作，将数据存放到用户定义的接收缓冲区**;

2.当一帧数据发送完成后，线路处于IDLE状态，将触发IDLE中断，调用**IDLE中断回调函数（用户自己编写，位于main.c）**，**设置数据接收完成标志;**

3.主程序检测到接收完成标志置位后，先清除标志位，将接收的一帧数据原样发回到PC

4.**接收数据个数置零，清空接收缓冲区**

5.**重新启动DMA传输**。

![image-20210803161620389](image-20210803161620389.png)

##### 实现（坑很多！）

###### 0.基本配置（略）

（1）点击USATR1
（2）设置MODE为异步通信(Asynchronous)
（3）基础参数：波特率为115200 Bits/s。传输数据长度为8 Bit。奇偶检验无，停止位1 接收和发送都使能
（4）GPIO引脚自动设置 USART1_RX/USART_TX
（5）NVIC Settings 一栏使能接收中断

**注意：如果不开启串口中断，则程序只能发送一次数据,程序不能判断DMA传输是否完成，USART一直处于busy状态。**

![image-20210803001828406](image-20210803001828406.png)

###### 1.配置UART1的DMA

- **点击DMA Settings 点击 Add 添加通道**
- **选择USART_RX**    **USART_TX** **传输速率默认**
- **方向分别为 外设到内存 和 内存到外设**
- **DMA传输模式为普通模式**
- **DMA内存地址自增，每次增加一个Byte(字节)**

![image-20210803001746763](image-20210803001746763.png)

![image-20210803005324824](image-20210803005324824.png)

###### 2.程序编写

![image-20210803161620389](image-20210803161620389.png)

（0）定义各类变量

![image-20210803161923504](image-20210803161923504.png)

```c
/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */
# define LENGTH 255 // 接收缓冲区按大小，该值需要大于一帧数据的总字符数
/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
uint8_t RxBuffer[LENGTH];          // 接收缓冲区
volatile uint8_t RecCount = 0;     // 接收数据个数（一帧数据的长度）
volatile uint8_t RxFlag = 0;       // 接收完成标志：0表示未完成,1表示完成
// 下面的一定要声明
extern UART_HandleTypeDef huart1;
extern DMA_HandleTypeDef hdma_usart1_rx;
extern DMA_HandleTypeDef hdma_usart1_tx;
/* USER CODE END PV */
```

（1）用户初始化代码

（main.c中的main函数中）

![image-20210803162143899](image-20210803162143899.png)

```c
 /* USER CODE BEGIN 2 */
	__HAL_UART_ENABLE_IT(&huart1,UART_IT_IDLE); // 使能IDLE中断
	HAL_UART_Receive_DMA(&huart1,RxBuffer,LENGTH); // 启动DMA接收（一定要加）
  /* USER CODE END 2 */
```

（2）添加IDLE中断处理

![image-20210803162347929](image-20210803162347929.png)

```c
/**
  * @brief This function handles USART1 global interrupt.
  * 添加空闲IDLE中断的处理
  */
void USART1_IRQHandler(void)
{
  /* USER CODE BEGIN USART1_IRQn 0 */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
  /* USER CODE BEGIN USART1_IRQn 1 */
	// 判断是否发生IDLE中断
	if(__HAL_UART_GET_FLAG(&huart1,UART_FLAG_IDLE) != RESET)
	{
		//清除IDLE中断标志
		__HAL_UART_CLEAR_IDLEFLAG(&huart1);
		// 停止DMA接收
			HAL_UART_DMAStop(&huart1);
		//调用用户编写的IDLE中断回调函数(位于main.c中)
		HAL_UART_IdleCpltCallback(&huart1);
	}
  /* USER CODE END USART1_IRQn 1 */
}
```

（3）重写IDLE中断回调函数

![image-20210803162623315](image-20210803162623315.png)

```c
/* USER CODE BEGIN 4 */

/* 名称：空闲中断回调函数 HAL_UART_IdleCpltCallback
 * 用途：当一帧数据发送完成后，线路处于IDLE状态，
 *       将触发IDLE中断，调用空闲中断回调函数
 * 参数：串口句柄地址
 * 功能：设置数据接收完成标志
*/
void HAL_UART_IdleCpltCallback(UART_HandleTypeDef *huart)
{
		RxFlag = 1; // 设置接收完成标志
}

/* USER CODE END 4 */
```

（4）主函数while循环

![image-20210803164039798](image-20210803164039798.png)

```c
 /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
		if(RxFlag == 1) // 如果接收完成
		{
			// 清除标志位
			RxFlag = 0;
			// 发生空闲中断时，已接受数据个数=数据总量-DMA数据流中待接收的数据个数
			tmp = __HAL_DMA_GET_COUNTER(&hdma_usart1_rx);
			RecCount = LENGTH - tmp;
			// 采用DMA方式将接受到的数据原样发回到PC
			HAL_UART_Transmit_DMA(&huart1,(uint8_t*)&RxBuffer,RecCount);
			// RecCount置零,清除接收缓冲区
			RecCount = 0;
			memset(RxBuffer,0,RecCount);
//			for(uint8_t i=0;i<RecCount;i++)
//			{
//					RxBuffer[i]=0;//清接收缓存
//			}
			// 重新开启DMA接收
			HAL_UART_Receive_DMA(&huart1, (uint8_t*)&RxBuffer, LENGTH);
		}
  }
  /* USER CODE END 3 */
```

##### 3.效果

![image-20210803164114025](image-20210803164114025.png)

